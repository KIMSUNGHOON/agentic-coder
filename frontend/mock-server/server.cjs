/**
 * Mock API Server for local development without vLLM
 * Usage: npm run mock
 */
const express = require('express');
const cors = require('cors');
const app = express();
const PORT = 8000;

app.use(cors());
app.use(express.json());

// In-memory storage for conversations
const conversations = new Map();
let conversationCounter = 1;

// Mock data
const mockModels = [
  {
    name: 'mock-coding-model',
    endpoint: 'http://localhost:8000/mock',
    type: 'coding'
  },
  {
    name: 'mock-reasoning-model',
    endpoint: 'http://localhost:8000/mock',
    type: 'reasoning'
  }
];

const mockResponses = [
  "I understand your request. Let me help you with that!",
  "Here's a solution to your problem:\n\n```python\ndef example():\n    return 'Hello, World!'\n```",
  "Great question! Let me break this down for you...",
  "I've analyzed your code and found a few improvements we can make.",
  "Let me think about this step by step:\n1. First, we need to...\n2. Then, we should...\n3. Finally, we can..."
];

// Helper functions
function generateSessionId() {
  return `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

function getRandomResponse() {
  return mockResponses[Math.floor(Math.random() * mockResponses.length)];
}

function simulateTyping(text, delayMs = 50) {
  return new Promise((resolve) => {
    let index = 0;
    const chunks = [];

    while (index < text.length) {
      const chunkSize = Math.floor(Math.random() * 10) + 5;
      chunks.push(text.slice(index, index + chunkSize));
      index += chunkSize;
    }

    resolve(chunks);
  });
}

// Routes

// Health check
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok', mode: 'mock' });
});

// List models
app.get('/api/models', (req, res) => {
  res.json({ models: mockModels });
});

// Chat (non-streaming)
app.post('/api/chat', async (req, res) => {
  const { message, session_id, task_type } = req.body;

  console.log(`[Mock] Chat request: ${message.slice(0, 50)}...`);

  const response = getRandomResponse();
  const sessionId = session_id || generateSessionId();

  // Simulate processing delay
  await new Promise(resolve => setTimeout(resolve, 500));

  res.json({
    response,
    session_id: sessionId,
    task_type: task_type || 'coding'
  });
});

// Chat streaming
app.post('/api/chat/stream', async (req, res) => {
  const { message, session_id, task_type } = req.body;

  console.log(`[Mock] Stream request: ${message.slice(0, 50)}...`);

  res.setHeader('Content-Type', 'text/plain');
  res.setHeader('Transfer-Encoding', 'chunked');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');

  const response = getRandomResponse();
  const chunks = await simulateTyping(response);

  for (const chunk of chunks) {
    res.write(chunk);
    await new Promise(resolve => setTimeout(resolve, 50));
  }

  res.end();
});

// Agent status
app.get('/api/agent/status/:sessionId', (req, res) => {
  const { sessionId } = req.params;

  res.json({
    session_id: sessionId,
    message_count: 0,
    history: []
  });
});

// Clear history
app.post('/api/agent/clear/:sessionId', (req, res) => {
  const { sessionId } = req.params;
  console.log(`[Mock] Cleared history for session: ${sessionId}`);
  res.json({ status: 'ok' });
});

// Workflow execute - Enhanced with Quality Gate and HITL simulation
app.post('/api/workflow/execute', async (req, res) => {
  const { message, session_id, enable_hitl = true } = req.body;

  console.log(`[Mock] Workflow request: ${message.slice(0, 50)}...`);

  res.setHeader('Content-Type', 'application/json');
  res.setHeader('Transfer-Encoding', 'chunked');
  res.setHeader('Cache-Control', 'no-cache');

  // Planning phase
  res.write(JSON.stringify({
    agent: 'PlanningAgent',
    type: 'thinking',
    status: 'running',
    message: 'ìš”ì²­ì„ ë¶„ì„í•˜ê³  ê³„íšì„ ìƒì„± ì¤‘...'
  }) + '\n');
  await new Promise(resolve => setTimeout(resolve, 1000));

  const tasks = [
    { id: 1, task: 'í”„ë¡œì íŠ¸ êµ¬ì¡° ì„¤ì •', completed: false },
    { id: 2, task: 'í•µì‹¬ ê¸°ëŠ¥ êµ¬í˜„', completed: false },
    { id: 3, task: 'ì—ëŸ¬ ì²˜ë¦¬ ì¶”ê°€', completed: false }
  ];

  res.write(JSON.stringify({
    agent: 'PlanningAgent',
    type: 'completed',
    status: 'completed',
    items: tasks
  }) + '\n');
  await new Promise(resolve => setTimeout(resolve, 500));

  // Coding phase
  res.write(JSON.stringify({
    agent: 'CodingAgent',
    type: 'thinking',
    status: 'running',
    message: 'ê³„íšì— ë”°ë¼ ì½”ë“œ ì‘ì„± ì¤‘...',
    completed_tasks: []
  }) + '\n');
  await new Promise(resolve => setTimeout(resolve, 1000));

  const artifacts = [
    {
      type: 'code',
      language: 'python',
      filename: 'src/main.py',
      file_path: '/workspace/project/src/main.py',
      content: `# Example code generated by mock server
import os

def main():
    # Mock vulnerability for testing
    password = "admin123"  # Hardcoded credential
    query = f"SELECT * FROM users WHERE id = {user_id}"  # SQL injection
    os.system(user_cmd)  # Command injection
    print("Hello from mock workflow!")
    return True

if __name__ == "__main__":
    main()
`,
      action: 'created',
      saved: true
    },
    {
      type: 'code',
      language: 'python',
      filename: 'src/utils/helpers.py',
      file_path: '/workspace/project/src/utils/helpers.py',
      content: `# Helper functions
def process_data(data):
    result = eval(data)  # Dangerous eval
    return result
`,
      action: 'created',
      saved: true
    }
  ];

  res.write(JSON.stringify({
    agent: 'CodingAgent',
    type: 'artifact',
    status: 'running',
    artifact: artifacts[0],
    message: 'src/main.py ìƒì„±ë¨',
    completed_tasks: [
      { task_num: 1, task: 'í”„ë¡œì íŠ¸ êµ¬ì¡° ì„¤ì •', artifacts: ['src/main.py'] }
    ]
  }) + '\n');
  await new Promise(resolve => setTimeout(resolve, 800));

  res.write(JSON.stringify({
    agent: 'CodingAgent',
    type: 'artifact',
    status: 'running',
    artifact: artifacts[1],
    message: 'src/utils/helpers.py ìƒì„±ë¨',
    completed_tasks: [
      { task_num: 1, task: 'í”„ë¡œì íŠ¸ êµ¬ì¡° ì„¤ì •', artifacts: ['src/main.py'] },
      { task_num: 2, task: 'í•µì‹¬ ê¸°ëŠ¥ êµ¬í˜„', artifacts: ['src/utils/helpers.py'] }
    ]
  }) + '\n');
  await new Promise(resolve => setTimeout(resolve, 800));

  res.write(JSON.stringify({
    agent: 'CodingAgent',
    type: 'completed',
    status: 'completed',
    artifacts: artifacts,
    checklist: tasks.map(t => ({ ...t, completed: true }))
  }) + '\n');
  await new Promise(resolve => setTimeout(resolve, 500));

  // Quality Gate - Security Check
  res.write(JSON.stringify({
    agent: 'SecurityGate',
    type: 'thinking',
    status: 'running',
    message: 'ë³´ì•ˆ ì·¨ì•½ì  ê²€ì‚¬ ì¤‘...'
  }) + '\n');
  await new Promise(resolve => setTimeout(resolve, 1000));

  const securityFindings = [
    { severity: 'critical', category: 'SQL Injection', description: 'f-string SQL ì¿¼ë¦¬ ë°œê²¬', file: 'src/main.py', line: 8 },
    { severity: 'high', category: 'Command Injection', description: 'os.system() ì‚¬ìš©', file: 'src/main.py', line: 9 },
    { severity: 'high', category: 'Hardcoded Credential', description: 'í•˜ë“œì½”ë”©ëœ ë¹„ë°€ë²ˆí˜¸', file: 'src/main.py', line: 6 },
    { severity: 'critical', category: 'Code Injection', description: 'eval() ì‚¬ìš©', file: 'src/utils/helpers.py', line: 4 }
  ];

  res.write(JSON.stringify({
    agent: 'SecurityGate',
    type: 'completed',
    status: 'completed',
    passed: false,
    findings: securityFindings,
    message: `${securityFindings.length}ê°œ ë³´ì•ˆ ì´ìŠˆ ë°œê²¬`
  }) + '\n');
  await new Promise(resolve => setTimeout(resolve, 500));

  // Quality Gate - QA Check
  res.write(JSON.stringify({
    agent: 'QAGate',
    type: 'thinking',
    status: 'running',
    message: 'QA í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì¤‘...'
  }) + '\n');
  await new Promise(resolve => setTimeout(resolve, 800));

  const qaResults = [
    { test_name: 'test_main_function', passed: true, error: null },
    { test_name: 'test_input_validation', passed: false, error: 'AssertionError: Missing input validation' },
    { test_name: 'test_error_handling', passed: false, error: 'No exception handling found' }
  ];

  res.write(JSON.stringify({
    agent: 'QAGate',
    type: 'completed',
    status: 'completed',
    passed: false,
    results: qaResults,
    message: `${qaResults.filter(r => r.passed).length}/${qaResults.length} í…ŒìŠ¤íŠ¸ í†µê³¼`
  }) + '\n');
  await new Promise(resolve => setTimeout(resolve, 500));

  // Review phase
  res.write(JSON.stringify({
    agent: 'ReviewAgent',
    type: 'thinking',
    status: 'running',
    message: 'ìƒì„±ëœ ì½”ë“œ ê²€í†  ì¤‘...'
  }) + '\n');
  await new Promise(resolve => setTimeout(resolve, 1000));

  const reviewIssues = [
    'ì…ë ¥ ìœ íš¨ì„± ê²€ì‚¬ ëˆ„ë½',
    'ì—ëŸ¬ ì²˜ë¦¬ ê°œì„  í•„ìš”',
    'ë³´ì•ˆ ì·¨ì•½ì  ìˆ˜ì • í•„ìš”'
  ];

  const reviewSuggestions = [
    'ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì¶”ê°€ ê¶Œì¥',
    'docstring ë¬¸ì„œí™” ì¶”ê°€',
    'íƒ€ì… íŒíŠ¸ ì‚¬ìš© ê¶Œì¥'
  ];

  res.write(JSON.stringify({
    agent: 'ReviewAgent',
    type: 'completed',
    status: 'completed',
    approved: false,
    issues: reviewIssues,
    suggestions: reviewSuggestions,
    quality_score: 0.45
  }) + '\n');
  await new Promise(resolve => setTimeout(resolve, 500));

  // HITL Request (if enabled)
  if (enable_hitl) {
    res.write(JSON.stringify({
      agent: 'Workflow',
      type: 'hitl_request',
      status: 'waiting',
      request_type: 'approval',
      message: 'Quality Gate ê²°ê³¼ ê²€í† ê°€ í•„ìš”í•©ë‹ˆë‹¤',
      content: {
        type: 'code_review',
        summary: `ë³´ì•ˆ ì´ìŠˆ ${securityFindings.length}ê°œ ë°œê²¬\nQA ì‹¤íŒ¨ ${qaResults.filter(r => !r.passed).length}ê°œ\në¦¬ë·° ì´ìŠˆ ${reviewIssues.length}ê°œ`,
        artifacts_count: artifacts.length,
        quality_summary: {
          security_passed: false,
          qa_passed: false,
          review_approved: false
        },
        details: {
          artifacts: artifacts.map(a => ({ filename: a.filename, action: a.action })),
          security_findings: securityFindings,
          qa_results: qaResults,
          review_issues: reviewIssues,
          review_suggestions: reviewSuggestions,
          quality_score: 0.45
        }
      }
    }) + '\n');

    // Simulate waiting for HITL response
    await new Promise(resolve => setTimeout(resolve, 500));
  }

  // Final summary
  res.write(JSON.stringify({
    agent: 'Workflow',
    type: 'completed',
    status: 'finished',
    summary: {
      tasks_completed: 3,
      total_tasks: 3,
      artifacts_count: artifacts.length,
      security_issues: securityFindings.length,
      qa_failures: qaResults.filter(r => !r.passed).length,
      review_issues: reviewIssues.length,
      review_approved: false,
      requires_attention: true
    },
    artifacts: artifacts
  }) + '\n');

  res.end();
});

// HITL Response endpoint
app.post('/api/workflow/hitl/respond', async (req, res) => {
  const { session_id, checkpoint_id, response, feedback } = req.body;

  console.log(`[Mock] HITL Response: ${response} for checkpoint ${checkpoint_id}`);

  if (response === 'approve') {
    res.json({
      status: 'ok',
      message: 'ìŠ¹ì¸ë˜ì—ˆìŠµë‹ˆë‹¤. ì›Œí¬í”Œë¡œìš°ê°€ ê³„ì†ë©ë‹ˆë‹¤.',
      action: 'continue'
    });
  } else if (response === 'reject') {
    res.json({
      status: 'ok',
      message: 'ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤. ì½”ë“œê°€ ìˆ˜ì •ë©ë‹ˆë‹¤.',
      action: 'refine',
      feedback: feedback
    });
  } else if (response === 'modify') {
    res.json({
      status: 'ok',
      message: 'ìˆ˜ì • ìš”ì²­ì´ ì ‘ìˆ˜ë˜ì—ˆìŠµë‹ˆë‹¤.',
      action: 'modify',
      feedback: feedback
    });
  } else {
    res.json({
      status: 'ok',
      message: 'ì‘ë‹µì´ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤.',
      action: 'continue'
    });
  }
});

// Workspace API
app.get('/api/workspace/projects', (req, res) => {
  const { workspace } = req.query;

  res.json({
    projects: [
      { name: 'project_calculator', path: `${workspace || '/workspace'}/project_calculator`, files: 5, last_modified: new Date().toISOString() },
      { name: 'project_api_server', path: `${workspace || '/workspace'}/project_api_server`, files: 12, last_modified: new Date().toISOString() },
      { name: 'my_new_app', path: `${workspace || '/workspace'}/my_new_app`, files: 3, last_modified: new Date().toISOString() }
    ]
  });
});

// Conversations API
app.get('/api/conversations', (req, res) => {
  const { limit = 50, offset = 0, mode } = req.query;

  let convList = Array.from(conversations.values());
  if (mode) {
    convList = convList.filter(c => c.mode === mode);
  }

  const paginated = convList.slice(offset, offset + parseInt(limit));

  res.json({
    conversations: paginated,
    count: convList.length,
    limit: parseInt(limit),
    offset: parseInt(offset)
  });
});

app.get('/api/conversations/:sessionId', (req, res) => {
  const { sessionId } = req.params;
  const conv = conversations.get(sessionId);

  if (!conv) {
    return res.status(404).json({ error: 'Conversation not found' });
  }

  res.json(conv);
});

app.post('/api/conversations', (req, res) => {
  const { session_id, title, mode } = req.query;

  if (!conversations.has(session_id)) {
    const newConv = {
      id: conversationCounter++,
      session_id,
      title: title || 'New Conversation',
      mode: mode || 'chat',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      message_count: 0,
      messages: [],
      artifacts: [],
      workflow_state: null
    };

    conversations.set(session_id, newConv);
    res.json(newConv);
  } else {
    res.json(conversations.get(session_id));
  }
});

app.put('/api/conversations/:sessionId', (req, res) => {
  const { sessionId } = req.params;
  const { title } = req.query;
  const { workflow_state } = req.body;

  const conv = conversations.get(sessionId);
  if (!conv) {
    return res.status(404).json({ error: 'Conversation not found' });
  }

  if (title) conv.title = title;
  if (workflow_state) conv.workflow_state = workflow_state;
  conv.updated_at = new Date().toISOString();

  conversations.set(sessionId, conv);
  res.json(conv);
});

app.delete('/api/conversations/:sessionId', (req, res) => {
  const { sessionId } = req.params;
  conversations.delete(sessionId);
  res.json({ status: 'ok' });
});

app.post('/api/conversations/:sessionId/messages', (req, res) => {
  const { sessionId } = req.params;
  const { role, content } = req.query;

  const conv = conversations.get(sessionId);
  if (!conv) {
    return res.status(404).json({ error: 'Conversation not found' });
  }

  const message = {
    id: conv.messages.length + 1,
    role,
    content,
    created_at: new Date().toISOString()
  };

  conv.messages.push(message);
  conv.message_count = conv.messages.length;
  conv.updated_at = new Date().toISOString();

  conversations.set(sessionId, conv);
  res.json({ status: 'ok' });
});

app.post('/api/conversations/:sessionId/artifacts', (req, res) => {
  const { sessionId } = req.params;
  const { filename, language, content, task_num } = req.query;

  const conv = conversations.get(sessionId);
  if (!conv) {
    return res.status(404).json({ error: 'Conversation not found' });
  }

  const artifact = {
    id: conv.artifacts.length + 1,
    filename,
    language,
    content,
    task_num: task_num ? parseInt(task_num) : undefined,
    version: 1,
    created_at: new Date().toISOString()
  };

  conv.artifacts.push(artifact);
  conv.updated_at = new Date().toISOString();

  conversations.set(sessionId, conv);
  res.json({ status: 'ok' });
});

// Start server
app.listen(PORT, () => {
  console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                            â•‘
â•‘       ğŸ­ Mock API Server Running                          â•‘
â•‘                                                            â•‘
â•‘       Port: ${PORT}                                          â•‘
â•‘       Mode: MOCK (No vLLM required)                       â•‘
â•‘                                                            â•‘
â•‘       Frontend: http://localhost:5173                     â•‘
â•‘       API: http://localhost:${PORT}/api                      â•‘
â•‘                                                            â•‘
â•‘       Ready for testing! ğŸš€                               â•‘
â•‘                                                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  `);
});
