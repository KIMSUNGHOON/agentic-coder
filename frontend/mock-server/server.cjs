/**
 * Mock API Server for local development without vLLM
 * Usage: npm run mock
 */
const express = require('express');
const cors = require('cors');
const app = express();
const PORT = 8000;

app.use(cors());
app.use(express.json());

// In-memory storage for conversations
const conversations = new Map();
let conversationCounter = 1;

// Mock data
const mockModels = [
  {
    name: 'mock-coding-model',
    endpoint: 'http://localhost:8000/mock',
    type: 'coding'
  },
  {
    name: 'mock-reasoning-model',
    endpoint: 'http://localhost:8000/mock',
    type: 'reasoning'
  }
];

const mockResponses = [
  "I understand your request. Let me help you with that!",
  "Here's a solution to your problem:\n\n```python\ndef example():\n    return 'Hello, World!'\n```",
  "Great question! Let me break this down for you...",
  "I've analyzed your code and found a few improvements we can make.",
  "Let me think about this step by step:\n1. First, we need to...\n2. Then, we should...\n3. Finally, we can..."
];

// Helper functions
function generateSessionId() {
  return `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

function getRandomResponse() {
  return mockResponses[Math.floor(Math.random() * mockResponses.length)];
}

function simulateTyping(text, delayMs = 50) {
  return new Promise((resolve) => {
    let index = 0;
    const chunks = [];

    while (index < text.length) {
      const chunkSize = Math.floor(Math.random() * 10) + 5;
      chunks.push(text.slice(index, index + chunkSize));
      index += chunkSize;
    }

    resolve(chunks);
  });
}

// Routes

// Health check
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok', mode: 'mock' });
});

// List models
app.get('/api/models', (req, res) => {
  res.json({ models: mockModels });
});

// Chat (non-streaming)
app.post('/api/chat', async (req, res) => {
  const { message, session_id, task_type } = req.body;

  console.log(`[Mock] Chat request: ${message.slice(0, 50)}...`);

  const response = getRandomResponse();
  const sessionId = session_id || generateSessionId();

  // Simulate processing delay
  await new Promise(resolve => setTimeout(resolve, 500));

  res.json({
    response,
    session_id: sessionId,
    task_type: task_type || 'coding'
  });
});

// Chat streaming
app.post('/api/chat/stream', async (req, res) => {
  const { message, session_id, task_type } = req.body;

  console.log(`[Mock] Stream request: ${message.slice(0, 50)}...`);

  res.setHeader('Content-Type', 'text/plain');
  res.setHeader('Transfer-Encoding', 'chunked');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');

  const response = getRandomResponse();
  const chunks = await simulateTyping(response);

  for (const chunk of chunks) {
    res.write(chunk);
    await new Promise(resolve => setTimeout(resolve, 50));
  }

  res.end();
});

// Agent status
app.get('/api/agent/status/:sessionId', (req, res) => {
  const { sessionId } = req.params;

  res.json({
    session_id: sessionId,
    message_count: 0,
    history: []
  });
});

// Clear history
app.post('/api/agent/clear/:sessionId', (req, res) => {
  const { sessionId } = req.params;
  console.log(`[Mock] Cleared history for session: ${sessionId}`);
  res.json({ status: 'ok' });
});

// Workflow execute
app.post('/api/workflow/execute', async (req, res) => {
  const { message, session_id } = req.body;

  console.log(`[Mock] Workflow request: ${message.slice(0, 50)}...`);

  res.setHeader('Content-Type', 'application/json');
  res.setHeader('Transfer-Encoding', 'chunked');
  res.setHeader('Cache-Control', 'no-cache');

  // Planning phase
  res.write(JSON.stringify({
    agent: 'PlanningAgent',
    type: 'thinking',
    status: 'running',
    message: 'Analyzing your request and creating a plan...'
  }) + '\n');
  await new Promise(resolve => setTimeout(resolve, 1000));

  const tasks = [
    { id: 1, task: 'Set up project structure', completed: false },
    { id: 2, task: 'Implement core functionality', completed: false },
    { id: 3, task: 'Add error handling', completed: false }
  ];

  res.write(JSON.stringify({
    agent: 'PlanningAgent',
    type: 'completed',
    status: 'completed',
    items: tasks
  }) + '\n');
  await new Promise(resolve => setTimeout(resolve, 500));

  // Coding phase
  res.write(JSON.stringify({
    agent: 'CodingAgent',
    type: 'thinking',
    status: 'running',
    message: 'Writing code based on the plan...',
    completed_tasks: []
  }) + '\n');
  await new Promise(resolve => setTimeout(resolve, 1000));

  const artifact = {
    type: 'code',
    language: 'python',
    filename: 'example.py',
    content: `# Example code generated by mock server
def main():
    print("Hello from mock workflow!")
    return True

if __name__ == "__main__":
    main()
`
  };

  res.write(JSON.stringify({
    agent: 'CodingAgent',
    type: 'artifact',
    status: 'running',
    artifact,
    message: 'Created example.py',
    completed_tasks: [
      { task_num: 1, task: 'Set up project structure', artifacts: ['example.py'] }
    ]
  }) + '\n');
  await new Promise(resolve => setTimeout(resolve, 1000));

  res.write(JSON.stringify({
    agent: 'CodingAgent',
    type: 'completed',
    status: 'completed',
    artifacts: [artifact],
    checklist: tasks.map(t => ({ ...t, completed: true }))
  }) + '\n');
  await new Promise(resolve => setTimeout(resolve, 500));

  // Review phase
  res.write(JSON.stringify({
    agent: 'ReviewAgent',
    type: 'thinking',
    status: 'running',
    message: 'Reviewing the generated code...'
  }) + '\n');
  await new Promise(resolve => setTimeout(resolve, 1000));

  res.write(JSON.stringify({
    agent: 'ReviewAgent',
    type: 'completed',
    status: 'completed',
    approved: true,
    issues: [],
    suggestions: ['Consider adding unit tests', 'Add docstrings for better documentation']
  }) + '\n');
  await new Promise(resolve => setTimeout(resolve, 500));

  // Final summary
  res.write(JSON.stringify({
    agent: 'Workflow',
    type: 'completed',
    status: 'finished',
    summary: {
      tasks_completed: 3,
      total_tasks: 3,
      artifacts_count: 1,
      review_approved: true
    }
  }) + '\n');

  res.end();
});

// Conversations API
app.get('/api/conversations', (req, res) => {
  const { limit = 50, offset = 0, mode } = req.query;

  let convList = Array.from(conversations.values());
  if (mode) {
    convList = convList.filter(c => c.mode === mode);
  }

  const paginated = convList.slice(offset, offset + parseInt(limit));

  res.json({
    conversations: paginated,
    count: convList.length,
    limit: parseInt(limit),
    offset: parseInt(offset)
  });
});

app.get('/api/conversations/:sessionId', (req, res) => {
  const { sessionId } = req.params;
  const conv = conversations.get(sessionId);

  if (!conv) {
    return res.status(404).json({ error: 'Conversation not found' });
  }

  res.json(conv);
});

app.post('/api/conversations', (req, res) => {
  const { session_id, title, mode } = req.query;

  if (!conversations.has(session_id)) {
    const newConv = {
      id: conversationCounter++,
      session_id,
      title: title || 'New Conversation',
      mode: mode || 'chat',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      message_count: 0,
      messages: [],
      artifacts: [],
      workflow_state: null
    };

    conversations.set(session_id, newConv);
    res.json(newConv);
  } else {
    res.json(conversations.get(session_id));
  }
});

app.put('/api/conversations/:sessionId', (req, res) => {
  const { sessionId } = req.params;
  const { title } = req.query;
  const { workflow_state } = req.body;

  const conv = conversations.get(sessionId);
  if (!conv) {
    return res.status(404).json({ error: 'Conversation not found' });
  }

  if (title) conv.title = title;
  if (workflow_state) conv.workflow_state = workflow_state;
  conv.updated_at = new Date().toISOString();

  conversations.set(sessionId, conv);
  res.json(conv);
});

app.delete('/api/conversations/:sessionId', (req, res) => {
  const { sessionId } = req.params;
  conversations.delete(sessionId);
  res.json({ status: 'ok' });
});

app.post('/api/conversations/:sessionId/messages', (req, res) => {
  const { sessionId } = req.params;
  const { role, content } = req.query;

  const conv = conversations.get(sessionId);
  if (!conv) {
    return res.status(404).json({ error: 'Conversation not found' });
  }

  const message = {
    id: conv.messages.length + 1,
    role,
    content,
    created_at: new Date().toISOString()
  };

  conv.messages.push(message);
  conv.message_count = conv.messages.length;
  conv.updated_at = new Date().toISOString();

  conversations.set(sessionId, conv);
  res.json({ status: 'ok' });
});

app.post('/api/conversations/:sessionId/artifacts', (req, res) => {
  const { sessionId } = req.params;
  const { filename, language, content, task_num } = req.query;

  const conv = conversations.get(sessionId);
  if (!conv) {
    return res.status(404).json({ error: 'Conversation not found' });
  }

  const artifact = {
    id: conv.artifacts.length + 1,
    filename,
    language,
    content,
    task_num: task_num ? parseInt(task_num) : undefined,
    version: 1,
    created_at: new Date().toISOString()
  };

  conv.artifacts.push(artifact);
  conv.updated_at = new Date().toISOString();

  conversations.set(sessionId, conv);
  res.json({ status: 'ok' });
});

// Start server
app.listen(PORT, () => {
  console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                            â•‘
â•‘       ğŸ­ Mock API Server Running                          â•‘
â•‘                                                            â•‘
â•‘       Port: ${PORT}                                          â•‘
â•‘       Mode: MOCK (No vLLM required)                       â•‘
â•‘                                                            â•‘
â•‘       Frontend: http://localhost:5173                     â•‘
â•‘       API: http://localhost:${PORT}/api                      â•‘
â•‘                                                            â•‘
â•‘       Ready for testing! ğŸš€                               â•‘
â•‘                                                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  `);
});
